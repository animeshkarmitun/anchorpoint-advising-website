import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { v4 as uuidv4 } from 'uuid';
import { PrismaService } from '../prisma/prisma.service';
import {
    UpdateRegistrationModeDto,
    GenerateInviteDto,
    UpdateSettingDto,
} from './dto/settings.dto';

@Injectable()
export class SettingsService {
    private readonly logger = new Logger(SettingsService.name);

    constructor(private readonly prisma: PrismaService) { }

    // ─── Registration Gate ─────────────────────────────

    async getRegistrationSettings() {
        const modeSetting = await this.prisma.setting.findUnique({
            where: { key: 'registration_mode' },
        });

        const invites = await this.prisma.inviteToken.findMany({
            orderBy: { createdAt: 'desc' },
        });

        return {
            success: true,
            message: 'Registration settings',
            data: {
                mode: modeSetting ? JSON.parse(modeSetting.value as string) : 'OPEN',
                invites: invites.map((inv) => ({
                    id: inv.id,
                    token: inv.token,
                    maxUses: inv.maxUses,
                    usedCount: inv.usedCount,
                    expiresAt: inv.expiresAt,
                    active: inv.active,
                    expired: inv.expiresAt < new Date(),
                    depleted: inv.maxUses ? inv.usedCount >= inv.maxUses : false,
                    createdAt: inv.createdAt,
                })),
            },
        };
    }

    async updateRegistrationMode(
        dto: UpdateRegistrationModeDto,
        userId: string,
        ip?: string,
    ) {
        const oldSetting = await this.prisma.setting.findUnique({
            where: { key: 'registration_mode' },
        });

        const oldValue = oldSetting
            ? JSON.parse(oldSetting.value as string)
            : 'OPEN';

        await this.prisma.setting.upsert({
            where: { key: 'registration_mode' },
            update: { value: JSON.stringify(dto.mode) },
            create: { key: 'registration_mode', value: JSON.stringify(dto.mode) },
        });

        // Audit log
        await this.prisma.auditLog.create({
            data: {
                userId,
                action: 'UPDATE',
                entity: 'Setting',
                entityId: 'registration_mode',
                oldValue: { mode: oldValue },
                newValue: { mode: dto.mode },
                ip,
            },
        });

        this.logger.log(
            `Registration mode changed: ${oldValue} → ${dto.mode} by ${userId}`,
        );

        return {
            success: true,
            message: `Registration mode updated to ${dto.mode}`,
            data: { mode: dto.mode, previousMode: oldValue },
        };
    }

    async generateInviteToken(dto: GenerateInviteDto, userId: string) {
        const token = uuidv4();
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + (dto.expiryDays || 7));

        const invite = await this.prisma.inviteToken.create({
            data: {
                token,
                maxUses: dto.maxUses || null,
                expiresAt,
                createdBy: userId,
            },
        });

        this.logger.log(`Invite token generated by ${userId}: ${token}`);

        return {
            success: true,
            message: 'Invite token generated',
            data: {
                id: invite.id,
                token: invite.token,
                inviteUrl: `${process.env.FRONTEND_URL || 'http://localhost:3011'}/register?invite=${invite.token}`,
                maxUses: invite.maxUses,
                expiresAt: invite.expiresAt,
            },
        };
    }

    async listInviteTokens() {
        const invites = await this.prisma.inviteToken.findMany({
            orderBy: { createdAt: 'desc' },
        });

        return {
            success: true,
            message: 'Invite tokens',
            data: invites.map((inv) => ({
                ...inv,
                expired: inv.expiresAt < new Date(),
                depleted: inv.maxUses ? inv.usedCount >= inv.maxUses : false,
                status: !inv.active
                    ? 'REVOKED'
                    : inv.expiresAt < new Date()
                        ? 'EXPIRED'
                        : inv.maxUses && inv.usedCount >= inv.maxUses
                            ? 'DEPLETED'
                            : 'ACTIVE',
            })),
        };
    }

    async revokeInviteToken(id: string) {
        const invite = await this.prisma.inviteToken.findUnique({
            where: { id },
        });

        if (!invite) {
            throw new NotFoundException('Invite token not found');
        }

        await this.prisma.inviteToken.update({
            where: { id },
            data: { active: false },
        });

        return {
            success: true,
            message: 'Invite token revoked',
            data: null,
        };
    }

    // ─── General Settings ──────────────────────────────

    async getAllSettings() {
        const settings = await this.prisma.setting.findMany();

        const parsed: Record<string, any> = {};
        settings.forEach((s) => {
            try {
                parsed[s.key] = JSON.parse(s.value as string);
            } catch {
                parsed[s.key] = s.value;
            }
        });

        return {
            success: true,
            message: 'All settings',
            data: parsed,
        };
    }

    async updateSetting(
        key: string,
        dto: UpdateSettingDto,
        userId: string,
        ip?: string,
    ) {
        const existing = await this.prisma.setting.findUnique({
            where: { key },
        });

        const oldValue = existing ? existing.value : null;

        await this.prisma.setting.upsert({
            where: { key },
            update: { value: JSON.stringify(dto.value) },
            create: { key, value: JSON.stringify(dto.value) },
        });

        // Audit log
        await this.prisma.auditLog.create({
            data: {
                userId,
                action: 'UPDATE',
                entity: 'Setting',
                entityId: key,
                oldValue: { value: oldValue },
                newValue: { value: dto.value },
                ip,
            },
        });

        return {
            success: true,
            message: `Setting "${key}" updated`,
            data: { key, value: dto.value },
        };
    }

    // ─── Public helpers ────────────────────────────────

    async getRegistrationMode(): Promise<string> {
        const setting = await this.prisma.setting.findUnique({
            where: { key: 'registration_mode' },
        });
        return setting ? JSON.parse(setting.value as string) : 'OPEN';
    }
}
